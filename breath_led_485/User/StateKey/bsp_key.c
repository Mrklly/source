#include <string.h>
#include "bsp_key.h"
#include "bsp_timer.h"
#include "bsp_wwdg.h"
#include "global_variable.h"


const key_io_t key_define[4] = {
    {KEY1_PORT, KEY1_PIN},
    {KEY2_PORT, KEY2_PIN},
    {KEY3_PORT, KEY3_PIN},
    {KEY4_PORT, KEY4_PIN}
};



/*****************************************************************************************************
*程序名：KEY_Init
***功能：配置4个独立按键，工作在上拉输入模式。
***参数：无参数。
*返回值：无返回值。
***作者：王利均
***时间：2018年4月21号。
*****************************************************************************************************/
void KEY_Init(void)
{
  GPIO_Init(KEY1_PORT,KEY1_PIN, GPIO_MODE_IN_PU_NO_IT);//库函数：配置为无中断上拉输入。
  GPIO_Init(KEY2_PORT,KEY2_PIN, GPIO_MODE_IN_PU_NO_IT);//库函数：配置为无中断上拉输入。
  GPIO_Init(KEY3_PORT,KEY3_PIN, GPIO_MODE_IN_PU_NO_IT);//库函数：配置为无中断上拉输入。
  GPIO_Init(KEY4_PORT,KEY4_PIN, GPIO_MODE_IN_PU_NO_IT);//库函数：配置为无中断上拉输入。
}
/*****************************************************************************************************
*程序名：scan_key
***功能：IO口扫描函数，扫描4个按键IO口状态。返回一个IO状态。
***参数：无参数。
*返回值：返回键值。
***作者：王利均
***时间：2018年8月21号。
*****************************************************************************************************/
uint8_t Key_Scan(void)
{
  volatile uint8_t KeyTemp=0x00;                               //用来做临时按键值。
  if(GPIO_ReadInputPin(KEY1_PORT,KEY1_PIN)==0)        //Key按键1
  { 
    KeyTemp=KEY1_VALUE;

  } else if(GPIO_ReadInputPin(KEY2_PORT,KEY2_PIN)==0)   //KEY按键2
  {
    KeyTemp=KEY2_VALUE;                            
  } else if(GPIO_ReadInputPin(KEY3_PORT,KEY3_PIN)==0)  //KEY按键3
  {
    KeyTemp=KEY3_VALUE;
  } else if(GPIO_ReadInputPin(KEY4_PORT,KEY4_PIN)==0)  //KEY按键4
  {
    KeyTemp=KEY4_VALUE;
  } else {
    KeyTemp=NO_KEY;
  }
  return KeyTemp;
}

uint8_t Key_value_detection (void)
{// key_Result[4]
    static uint8_t state[4] = {0, 0, 0, 0};                       //按键初始化按键状态机标志。                           
    static uint8_t key_last[4] = {0, 0, 0, 0};                    //上一次按键记录。                        
    static uint8_t key_now[4] = {0, 0, 0, 0};                     //现在按键记录。 
    static uint8_t time_cont[4] = {0, 0, 0, 0};                      //长按计时。
    uint8_t key_value[4] = {0, 0, 0, 0};                          //键值。

//    key_now = Key_Scan();                           //读取按键值。

    uint8_t i = 0;

    for(; i<4; i++) {

        if(KEY_CHECK(key_define[i].key_port, key_define[i].key_pin) == 0) {
            key_now[i] = 1 << i;
        } else {
            key_now[i] = 0;
        }

        switch(state[i])  {

        case STATE_KEY_UP:                            //初始化按键状态。
            if(key_now[i] != key_last[i]) {                     //判断本次按键是否与上一次按键相等。
                state[i] = 1;                                //转换到按键去抖状态。
            }
            key_value[i] = 0;
            time_cont[i] = 0;
            break;
        case STATE_KEY_DOWM:                          //按键去抖动
            if(key_now[i] == key_last[i]) {
            
                state[i] = 2;                                //转换到按键短按状态。
                key_value[i] = key_last[i]|KEY_SHORT;

            } else {
                state[i] = 0;                                //是抖动。
                key_value[i] = 0;
            }
            time_cont[i] = 0;
            break;
        case STATE_KEY_SHORT:                         //按键短按状态。
            if(key_now[i] == key_last[i]) {                     //有按键按下。
                state[i] = 3;                                //转换到按键长按状态。
            } else {                                      //短按按键。
                state[i] = 0;
    //           key_value[i] = key_last[i]|KEY_SHORT;         //键值短按。
            }
            key_value[i] = 0;
            time_cont[i] = 0;
            break;
        case STATE_KEY_LONG:                         //长按状态。
            if(key_now[i] == key_last[i]) {                    //开始计时。
                if(time_cont[i]++ > 75) {                   //1.5秒以上为长按。
                    time_cont[i] = 0;
                    state[i] = 4;                             //按键转换为等待长按释放状态。
                    key_value[i] = key_last[i] | KEY_LONG;       //键值是长按。
                }
            } else {
                state[i] = 0;
    //           key_value[i] = key_last[i]|KEY_SHORT;        //键值修改为短按。
            }
            break;
        case STATE_KEY_LONG_UP:                      //长按松手检测
            if(key_now[i] != key_last[i]) {                 //按键释放
                key_value[i] = key_last[i] | KEY_LONG_UP;      //键值修改为长按抬起。
                if(key_now[i] == NO_KEY) {                   //按键正常抬起。
                    state[i] = 0;
                } else {                                  //别的按键按下造成抬起。
                    state[i] = 1;
                }
            }
            time_cont[i] = 0;
            break;
            default:
            key_value[i] = 0;
            key_last[i] = 0;
            key_now[i] = 0;
            break;
        }

        key_last[i] = key_now[i];                          //更新记录上一次按键。

    }

//    return key_value;                           //返回键值。

    memcpy(key_Result, key_value, 4);
    
    return 0;
}

